[DEFAULT]
bind_ip = 0.0.0.0
bind_port = 8080
user = root
# Consider using 1 worker per CPU
workers = 300


#yes proxy-logging appears twice to capture middleware events
[pipeline:main]
#pipeline = catch_errors healthcheck proxy-logging cache tempurl formpost swift3 proxy-logging proxy-server
#pipeline = catch_errors healthcheck proxy-logging cache formpost proxy-logging proxy-server
pipeline = catch_errors healthcheck proxy-logging cache formpost webhook proxy-logging proxy-server

[filter:tempurl] 
use = egg:swift#tempurl

[filter:formpost] 
use = egg:swift#formpost

#[filter:authtoken]
#paste.filter_factory = keystone.middleware.auth_token:filter_factory
#auth_host = KEYSTONE_HOSTNAME
#auth_port = 35357
#auth_protocol = http
#auth_uri = http://KEYSTONE_HOSTNAME:5000/
#admin_tenant_name = TENANT_NAME
#admin_user = SWIFT_USERNAME
#admin_password = SWIFT_PASSWORD
#include_service_catalog = False

[filter:swift3]
use = egg:swift3#swift3

#[filter:keystoneauth]
#use = egg:gluster_swift#keystoneauth
## Operator roles is the role which user would be allowed to manage a
## tenant and be able to create container or give ACL to others.
#operator_roles = Member, admin


[filter:gswauth]
use = egg:gluster_swift#gswauth
set log_name = gswauth
super_admin_key = gswauthkey
metadata_volume = gsmetadata
#auth_type = sha1
#auth_type_salt = swauthsalt
s3_support = on
token_life = 8640000
max_token_life = 8640000

[filter:tempauth]
use = egg:swift#tempauth
user_admin_admin = admin .admin .reseller_admin
user_gv0_gv0 = gv0 .admin
user_gv0_tester = testing .admin
#user_test_tester = testing .admin
#user_test2_tester2 = testing2 .admin
#user_test_tester3 = testing3
# To allow accounts/users with underscores you can base64 encode them.
# Here is the account "under_score" and username "a_b" (note the lack
# of padding equal signs):
#user64_dW5kZXJfc2NvcmU_YV9i = testing4
#token_life = 8640000
#max_token_life = 8640000

#[filter:gswauth]
#use = egg:gluster_swift#gswauth
#set log_name = gswauth
#super_admin_key = gswauthkey
#metadata_volume = gsmetadata
#auth_type = sha1
#auth_type_salt = swauthsalt
#token_life = 8640000
#max_token_life = 8640000


[app:proxy-server]
use = egg:gluster_swift#proxy
account_autocreate = true

log_facility = LOG_LOCAL1
log_level = DEBUG
# The API allows for account creation and deletion, but since Gluster/Swift
# automounts a Gluster volume for a given account, there is no way to create
# or delete an account. So leave this off.
allow_account_management = false
#account_autocreate = true
# The following parameters are used by object-expirer and needs to be same
# across all conf files!
auto_create_account_prefix = gs
expiring_objects_account_name = expiring
# Ensure the proxy server uses fast-POSTs since we don't need to make a copy
# of the entire object given that all metadata is stored in the object
# extended attributes (no .meta file used after creation) and no container
# sync feature to present.
object_post_as_copy = false
# Only need to recheck the account exists once a day
recheck_account_existence = 8640000
# May want to consider bumping this up if containers are created and destroyed
# infrequently.
recheck_container_existence = 864000
# Timeout clients that don't read or write to the proxy server after 5
# seconds.
client_timeout = 50
# Give more time to connect to the object, container or account servers in
# cases of high load.
conn_timeout = 60
# For high load situations, once connected to an object, container or account
# server, allow for delays communicating with them.
node_timeout = 360
# May want to consider bumping up this value to 1 - 4 MB depending on how much
# traffic is for multi-megabyte or gigabyte requests; perhaps matching the
# stripe width (not stripe element size) of your storage volume is a good
# starting point. See below for sizing information.
object_chunk_size = 65536
# If you do decide to increase the object_chunk_size, then consider lowering
# this value to one. Up to "put_queue_length" object_chunk_size'd buffers can
# be queued to the object server for processing. Given one proxy server worker
# can handle up to 1,024 connections, by default, it will consume 10 * 65,536
# * 1,024 bytes of memory in the worse case (default values). Be sure the
# amount of memory available on the system can accommodate increased values
# for object_chunk_size.
put_queue_depth = 100

[filter:catch_errors]
use = egg:swift#catch_errors

[filter:proxy-logging]
use = egg:swift#proxy_logging
access_log_level = DEBUG

[filter:healthcheck]
use = egg:swift#healthcheck

[filter:cache]
use = egg:swift#memcache
# Update this line to contain a comma separated list of memcache servers
# shared by all nodes running the proxy-server service.
memcache_servers = localhost:11211

[filter:webhook]
paste.filter_factory = swift.common.middleware.webhook:webhook_factory
